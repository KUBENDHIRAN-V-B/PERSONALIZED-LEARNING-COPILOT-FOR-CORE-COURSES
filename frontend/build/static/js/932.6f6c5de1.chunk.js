"use strict";(self.webpackChunklearning_copilot_frontend=self.webpackChunklearning_copilot_frontend||[]).push([[932],{2932(e,t,i){i.d(t,{BP:()=>c,h2:()=>s,is:()=>u,rh:()=>l});const n=i(6910).A.create({baseURL:"http://localhost:5000",timeout:15e3,headers:{"Content-Type":"application/json"}});n.interceptors.response.use(e=>e,e=>{try{if(e instanceof Error&&"response"in e){var t;401===(null===(t=e.response)||void 0===t?void 0:t.status)&&console.error("Unauthorized access")}}catch(i){console.error("Error in response interceptor:",i)}return Promise.reject(e)});const o=new Map,a=async(e,t)=>{const i="".concat(e,":").concat(JSON.stringify((null===t||void 0===t?void 0:t.params)||{})),a=o.get(i),r=Date.now();if(a&&r-a.timestamp<3e4)return a.data;try{const a=await n.get(e,t);if(o.size>=50){const e=o.keys().next().value;e&&o.delete(e)}return o.set(i,{data:a.data,timestamp:r}),a.data}catch(s){throw console.error("Failed to fetch ".concat(e,":"),s),s}},r=e=>{const t=e.toLowerCase();return t.includes("what is dsa")||t.includes("data structures and algorithms")?'**Data Structures and Algorithms (DSA)** is the foundation of computer science and programming. It involves:\n\n## Key Areas:\n- **Data Structures**: Arrays, Linked Lists, Stacks, Queues, Trees, Graphs, Hash Tables\n- **Algorithms**: Sorting, Searching, Dynamic Programming, Greedy Algorithms, Graph Algorithms\n\n## Why Learn DSA?\n- Essential for technical interviews at top companies (FAANG)\n- Improves problem-solving skills\n- Makes you a better programmer\n- Foundation for advanced topics like Machine Learning and System Design\n\n**Ready to start learning?** Try asking about specific data structures like "Explain Binary Trees" or algorithms like "How does Quick Sort work?"':t.includes("binary tree")||t.includes("tree")?"**Binary Trees** are hierarchical data structures where each node has at most two children (left and right).\n\n## Key Concepts:\n- **Root**: Topmost node\n- **Leaf**: Node with no children\n- **Height**: Longest path from root to leaf\n- **Balanced Tree**: Heights of subtrees differ by at most 1\n\n## Common Operations:\n- **Traversal**: Inorder, Preorder, Postorder, Level-order\n- **Insertion/Deletion**: O(log n) in balanced trees\n- **Search**: O(log n) average case\n\n## Applications:\n- Expression parsing, File systems, Database indexing\n- Binary Search Trees (BST) for ordered data\n\n**Example**: A balanced binary tree with height h can store up to 2^(h+1) - 1 nodes!":t.includes("sorting")||t.includes("sort")?"**Sorting Algorithms** arrange elements in a specific order (ascending/descending).\n\n## Popular Algorithms:\n\n### **Quick Sort** (Divide & Conquer)\n- **Time**: O(n log n) average, O(n\xb2) worst\n- **Space**: O(log n)\n- **Stable**: No\n- **Best for**: General purpose sorting\n\n### **Merge Sort**\n- **Time**: O(n log n) always\n- **Space**: O(n)\n- **Stable**: Yes\n- **Best for**: Large datasets, external sorting\n\n### **Bubble Sort**\n- **Time**: O(n\xb2)\n- **Space**: O(1)\n- **Stable**: Yes\n- **Best for**: Educational purposes, small arrays\n\n**Pro Tip**: For interviews, know the trade-offs between time/space complexity and stability!":t.includes("dynamic programming")||t.includes("dp")?"**Dynamic Programming (DP)** solves complex problems by breaking them into simpler subproblems.\n\n## Key Principles:\n1. **Optimal Substructure**: Solution built from optimal solutions of subproblems\n2. **Overlapping Subproblems**: Same subproblems solved multiple times\n\n## Famous DP Problems:\n- **Fibonacci**: Memoization vs Tabulation\n- **Knapsack**: 0/1 and Unbounded variants\n- **Longest Common Subsequence**\n- **Matrix Chain Multiplication**\n\n## Steps to Solve DP:\n1. Define the problem state\n2. Identify recurrence relation\n3. Determine base cases\n4. Choose memoization or tabulation\n5. Handle edge cases\n\n**Example**: Coin Change problem - Find minimum coins needed for a given amount!\n\nDP is challenging but mastering it will level up your problem-solving skills significantly!":t.includes("graph")||t.includes("graphs")?"**Graphs** represent relationships between objects using nodes (vertices) and edges.\n\n## Types:\n- **Directed**: Edges have direction (one-way)\n- **Undirected**: Edges are bidirectional\n- **Weighted**: Edges have costs/weights\n- **Unweighted**: All edges equal\n\n## Representations:\n- **Adjacency Matrix**: 2D array, O(V\xb2) space\n- **Adjacency List**: Array of lists, O(V + E) space\n\n## Algorithms:\n- **BFS/DFS**: Traversal\n- **Dijkstra**: Shortest path (weighted)\n- **Bellman-Ford**: Negative weights\n- **Floyd-Warshall**: All-pairs shortest path\n- **Kruskal/Prim**: Minimum Spanning Tree\n\n## Applications:\n- Social networks, GPS navigation, web crawling, dependency resolution\n\nGraphs are everywhere in computer science! \ud83c\udf10":t.includes("array")||t.includes("arrays")?"**Arrays** are the most fundamental data structure - contiguous memory blocks storing elements of the same type.\n\n## Key Operations:\n- **Access**: O(1) - Direct indexing\n- **Search**: O(n) linear, O(log n) binary (if sorted)\n- **Insert/Delete**: O(n) - Shifting elements\n\n## Common Problems:\n- **Two Sum**: Find pairs that sum to target\n- **Maximum Subarray**: Kadane's algorithm\n- **Rotate Array**: In-place rotation\n- **Merge Intervals**: Overlapping ranges\n\n## Multi-dimensional Arrays:\n- **2D Arrays**: Matrices, grids\n- **Applications**: Image processing, game boards, spreadsheets\n\n**Fun Fact**: Array indexing starts at 0 in most languages because memory is byte-addressable!\n\nArrays are simple but powerful - master them first!":t.includes("linked list")||t.includes("linkedlist")?"**Linked Lists** are dynamic data structures where elements are connected via pointers.\n\n## Types:\n- **Singly Linked List**: Each node points to next\n- **Doubly Linked List**: Nodes point to both next and previous\n- **Circular Linked List**: Last node points back to first\n\n## Operations:\n- **Insert/Delete**: O(1) at head, O(n) at tail (singly)\n- **Search**: O(n)\n- **Reverse**: O(n) time\n\n## Advantages over Arrays:\n- Dynamic size (no fixed capacity)\n- Efficient insertions/deletions\n- No memory waste\n\n## Common Problems:\n- **Reverse a Linked List**\n- **Detect Cycle** (Floyd's algorithm)\n- **Merge Two Sorted Lists**\n- **Remove Nth Node from End**\n\nLinked Lists teach pointer manipulation - crucial for interviews!":t.includes("stack")||t.includes("stacks")?"**Stacks** are LIFO (Last In, First Out) data structures.\n\n## Core Operations:\n- **Push**: Add element to top - O(1)\n- **Pop**: Remove top element - O(1)\n- **Peek/Top**: View top element - O(1)\n\n## Implementations:\n- **Array-based**: Fixed size, fast access\n- **Linked List**: Dynamic size, more flexible\n\n## Applications:\n- **Function Call Stack**: Recursion\n- **Expression Evaluation**: Infix to Postfix\n- **Browser History**: Back button\n- **Undo/Redo**: Text editors\n\n## Famous Problems:\n- **Valid Parentheses**: Stack-based validation\n- **Next Greater Element**\n- **Largest Rectangle in Histogram**\n\n**Stack Principle**: Last element added is first to be removed!":t.includes("queue")||t.includes("queues")?"**Queues** are FIFO (First In, First Out) data structures.\n\n## Core Operations:\n- **Enqueue**: Add to rear - O(1)\n- **Dequeue**: Remove from front - O(1)\n- **Front**: View front element - O(1)\n\n## Variants:\n- **Circular Queue**: Wraps around when full\n- **Priority Queue**: Elements dequeued by priority\n- **Deque**: Double-ended queue\n\n## Implementations:\n- **Array**: Fixed size, circular for efficiency\n- **Linked List**: Dynamic size\n\n## Applications:\n- **Task Scheduling**: CPU scheduling\n- **Breadth-First Search**: Level-order traversal\n- **Print Queue**: Document printing\n- **Message Queues**: Inter-process communication\n\n**Queue Principle**: First element added is first to be removed!":"I'm your DSA Learning Assistant! \ud83e\udd16\n\n**\"".concat(e,'"** is a great question for learning Data Structures and Algorithms!\n\n## What I can help you with:\n- **Data Structures**: Arrays, Linked Lists, Stacks, Queues, Trees, Graphs, Hash Tables\n- **Algorithms**: Sorting, Searching, Dynamic Programming, Greedy, Graph algorithms\n- **Problem Solving**: Interview questions, coding challenges, complexity analysis\n- **Concepts**: Time/Space complexity, Big O notation, optimization techniques\n\n## Try asking:\n- "Explain Binary Trees"\n- "How does Quick Sort work?"\n- "What is Dynamic Programming?"\n- "Graph traversal algorithms"\n\n**Ready to dive deep into DSA?** Let\'s start with the fundamentals and build up to advanced topics! \ud83d\ude80\n\n*Note: This is a demo response. Deploy the backend server with AI API keys for full interactive learning experience.*')},s={sendMessage:async(e,t,i)=>{if(!e||!t)throw new Error("Course ID and message are required");const o=localStorage.getItem("api_keys");let a={};if(o)try{a=JSON.parse(o).reduce((e,t)=>(e[t.name.toLowerCase()]=t.key,e),{})}catch(s){console.error("Error parsing API keys:",s)}try{return await n.post("/api/chat/message",{courseId:e,message:t,conversationId:i,apiKeys:a})}catch(s){return console.warn("Chat API failed, using mock response:",s),await new Promise(e=>setTimeout(e,1e3)),{data:{conversationId:i||"conv_".concat(Date.now()),aiResponse:r(t)}}}},getHistory:e=>{if(!e)throw new Error("Conversation ID is required");return n.get("/api/chat/history/".concat(e))}},c={getAll:async()=>{try{return await a("/api/courses")}catch(e){return console.warn("API call failed, falling back to mock data:",e),{courses:[{id:"dsa",name:"Data Structures & Algorithms",description:"Master fundamental data structures and algorithms for efficient problem-solving",topics:["Arrays","Linked Lists","Stacks","Queues","Trees","Graphs","Sorting","Searching","Dynamic Programming"],difficulty:"Intermediate",category:"CS",color:"from-blue-500 to-indigo-600"},{id:"programming",name:"Programming Fundamentals",description:"Learn the basics of programming with hands-on projects",topics:["Variables","Control Flow","Functions","Objects","Error Handling"],difficulty:"Beginner",category:"CS",color:"from-green-500 to-emerald-600"},{id:"discrete-math",name:"Discrete Mathematics",description:"Explore mathematical foundations of computer science",topics:["Sets","Logic","Graphs","Combinatorics","Number Theory"],difficulty:"Advanced",category:"CS",color:"from-purple-500 to-violet-600"},{id:"coa",name:"Computer Organization & Architecture",description:"Understand how computers work at the hardware level",topics:["CPU Architecture","Memory Hierarchy","I/O Systems","Pipelining"],difficulty:"Intermediate",category:"CS",color:"from-slate-500 to-gray-700"},{id:"os",name:"Operating Systems",description:"Learn about process management, memory management, and system calls",topics:["Processes","Threads","Memory Management","File Systems","Scheduling"],difficulty:"Intermediate",category:"CS",color:"from-orange-500 to-red-600"},{id:"dbms",name:"Database Management Systems",description:"Master SQL, database design, and data management principles",topics:["SQL","Normalization","Indexing","Transactions","NoSQL"],difficulty:"Intermediate",category:"CS",color:"from-cyan-500 to-blue-600"},{id:"cn",name:"Computer Networks",description:"Understand networking protocols, TCP/IP, and network security",topics:["TCP/IP","HTTP","Routing","Network Security","Wireless Networks"],difficulty:"Intermediate",category:"CS",color:"from-teal-500 to-cyan-600"},{id:"se",name:"Software Engineering",description:"Learn software development methodologies and best practices",topics:["SDLC","Agile","Testing","Requirements","Design Patterns"],difficulty:"Intermediate",category:"CS",color:"from-amber-500 to-orange-600"},{id:"digital-electronics",name:"Digital Electronics",description:"Learn digital logic circuits, gates, and digital system design",topics:["Logic Gates","Boolean Algebra","Combinational Circuits","Sequential Circuits","Flip-Flops"],difficulty:"Intermediate",category:"ECE",color:"from-red-500 to-pink-600"},{id:"analog-electronics",name:"Analog Electronics",description:"Master analog circuits, amplifiers, and signal processing",topics:["Diodes","Transistors","Amplifiers","Oscillators","Filters"],difficulty:"Intermediate",category:"ECE",color:"from-yellow-500 to-orange-600"},{id:"signals-systems",name:"Signals & Systems",description:"Understand signal processing, Fourier analysis, and system theory",topics:["Continuous Signals","Discrete Signals","Fourier Transform","Laplace Transform","Z-Transform"],difficulty:"Advanced",category:"ECE",color:"from-indigo-500 to-purple-600"},{id:"communication-systems",name:"Communication Systems",description:"Learn modulation, transmission, and communication protocols",topics:["AM/FM Modulation","Digital Communication","Channel Coding","Wireless Communication","Optical Communication"],difficulty:"Advanced",category:"ECE",color:"from-green-500 to-teal-600"},{id:"control-systems",name:"Control Systems",description:"Study feedback systems, stability analysis, and controller design",topics:["Transfer Functions","Stability Analysis","PID Controllers","State Space","Frequency Response"],difficulty:"Advanced",category:"ECE",color:"from-blue-500 to-cyan-600"},{id:"microprocessors",name:"Microprocessors & Microcontrollers",description:"Learn embedded systems programming and microcontroller architecture",topics:["8085/8086 Architecture","8051 Microcontroller","ARM Processors","Assembly Language","Embedded C"],difficulty:"Intermediate",category:"ECE",color:"from-purple-500 to-indigo-600"},{id:"electromagnetic-theory",name:"Electromagnetic Theory",description:"Understand electromagnetic waves, transmission lines, and antennas",topics:["Maxwell Equations","Wave Propagation","Transmission Lines","Antenna Theory","Microwave Engineering"],difficulty:"Advanced",category:"ECE",color:"from-slate-500 to-stone-600"},{id:"power-electronics",name:"Power Electronics",description:"Learn power conversion, motor drives, and renewable energy systems",topics:["Power Semiconductor Devices","DC-DC Converters","Inverters","Motor Drives","Renewable Energy"],difficulty:"Advanced",category:"ECE",color:"from-orange-500 to-amber-600"},{id:"vlsi-design",name:"VLSI Design",description:"Master integrated circuit design and semiconductor technology",topics:["CMOS Technology","Logic Design","Layout Design","Timing Analysis","FPGA Design"],difficulty:"Advanced",category:"ECE",color:"from-cyan-500 to-teal-600"},{id:"embedded-systems",name:"Embedded Systems",description:"Design and program embedded systems for real-world applications",topics:["Real-time Systems","RTOS","IoT","Sensor Networks","System-on-Chip"],difficulty:"Intermediate",category:"ECE",color:"from-emerald-500 to-green-600"}]}}},getById:e=>{if(!e)throw new Error("Course ID is required");return a("/api/courses/".concat(e))},enroll:e=>{if(!e)throw new Error("Course ID is required");return n.post("/api/courses/".concat(e,"/enroll"))}},l={getDashboard:async()=>{try{return await a("/api/analytics/dashboard")}catch(e){return console.warn("Analytics API failed, using mock data:",e),{totalSessions:24,totalTimeSpent:1800,averageAccuracy:82,coursesCompleted:1,currentStreak:5,weeklyGoal:7,weeklyProgress:5,recentSessions:[{date:"2024-01-10",duration:1800,accuracy:85,topic:"Binary Trees"},{date:"2024-01-09",duration:1500,accuracy:78,topic:"Graph Algorithms"},{date:"2024-01-08",duration:2100,accuracy:90,topic:"Dynamic Programming"}],topicMastery:[{topic:"trees",mastery:75,sessions:12},{topic:"graphs",mastery:60,sessions:8},{topic:"sorting",mastery:90,sessions:15},{topic:"dynamic programming",mastery:45,sessions:6}]}}},getExamReadiness:e=>{if(!e)throw new Error("Course ID is required");return a("/api/analytics/exam-readiness/".concat(e))},logSession:e=>{if(!e)throw new Error("Session data is required");return n.post("/api/analytics/session",e)},getInsights:async()=>{try{return await n.get("/api/analytics/insights")}catch(e){return console.warn("Insights API failed, using mock data:",e),{data:{peakFocusTime:{range:"9 AM - 11 AM",score:78,isCustom:!1,startHour:9,endHour:11},optimalDuration:{value:"25 minutes",avgAccuracy:85},masteryByTopic:[{topic:"trees",mastery:75,sessionsCount:12},{topic:"graphs",mastery:60,sessionsCount:8},{topic:"sorting",mastery:90,sessionsCount:15},{topic:"dynamic programming",mastery:45,sessionsCount:6}]}}}},startTimer:(e,t)=>{if(!e||!t)throw new Error("Topic and course ID are required");return n.post("/api/analytics/timer/start",{topic:e,courseId:t})},stopTimer:(e,t)=>n.post("/api/analytics/timer/stop",{accuracy:e,focusScore:t}),getTimerStatus:()=>n.get("/api/analytics/timer/status"),updateMastery:(e,t,i)=>{if(!e||void 0===t)throw new Error("Topic and score are required");return n.post("/api/analytics/mastery/update",{topic:e,score:t,timeSpent:i})},setFocusTime:(e,t)=>n.post("/api/analytics/preferences/focus-time",{startHour:e,endHour:t}),clearFocusTime:()=>n.delete("/api/analytics/preferences/focus-time"),setMasteryGoal:(e,t)=>{if(!e||void 0===t)throw new Error("Topic and goal are required");return n.post("/api/analytics/preferences/mastery-goal",{topic:e,goal:t})}},d=function(e,t){var i,n;let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5;const a={Arrays:{easy:[{id:1,question:"What is the time complexity of accessing an element in an array by index?",options:["O(n)","O(1)","O(log n)","O(n\xb2)"],correct:1,explanation:"Arrays provide constant time O(1) access using direct indexing."},{id:2,question:"Which operation is most efficient in an array?",options:["Insertion at beginning","Deletion from middle","Access by index","Linear search"],correct:2,explanation:"Accessing by index is O(1), making it the most efficient operation."},{id:3,question:"What is the space complexity of a static array?",options:["O(1)","O(n)","O(log n)","O(n\xb2)"],correct:1,explanation:"Static arrays have fixed size, so space complexity is O(1) for the array structure."}],medium:[{id:4,question:"Time complexity of inserting an element at the beginning of an array?",options:["O(1)","O(n)","O(log n)","O(n log n)"],correct:1,explanation:"Requires shifting all elements to the right, resulting in O(n) time."},{id:5,question:"Which array operation requires shifting elements?",options:["Access","Update","Insert/Delete","Search"],correct:2,explanation:"Insert and delete operations require shifting elements to maintain contiguous storage."}],hard:[{id:6,question:"Space complexity of a 2D array of size m\xd7n?",options:["O(1)","O(m+n)","O(m*n)","O(log(m*n))"],correct:2,explanation:"A 2D array stores m*n elements, so space complexity is O(m*n)."},{id:7,question:"In dynamic arrays, what happens when capacity is exceeded?",options:["Elements are lost","Array doubles in size","Program crashes","Elements are compressed"],correct:1,explanation:"Dynamic arrays typically double their capacity when full to maintain amortized O(1) insertions."}]},"Linked Lists":{easy:[{id:1,question:"What does a linked list node contain?",options:["Only data","Only pointer","Data and pointer","Multiple pointers"],correct:2,explanation:"A basic node contains data and a pointer to the next node."},{id:2,question:"What is the advantage of linked lists over arrays?",options:["Faster access","Dynamic size","Less memory","Simpler implementation"],correct:1,explanation:"Linked lists can grow and shrink dynamically without contiguous memory allocation."}],medium:[{id:3,question:"Time complexity of accessing the nth element in a linked list?",options:["O(1)","O(n)","O(log n)","O(n\xb2)"],correct:1,explanation:"Must traverse from the head node, requiring O(n) time in the worst case."},{id:4,question:"Which type of linked list allows traversal in both directions?",options:["Singly","Doubly","Circular","Static"],correct:1,explanation:"Doubly linked lists have pointers to both next and previous nodes."}],hard:[{id:5,question:"Time complexity of Floyd cycle detection algorithm?",options:["O(1)","O(n)","O(n\xb2)","O(log n)"],correct:1,explanation:"Floyd algorithm uses two pointers moving at different speeds, detecting cycles in O(n) time."},{id:6,question:"Space complexity of reversing a linked list iteratively?",options:["O(1)","O(n)","O(log n)","O(n\xb2)"],correct:0,explanation:"Iterative reversal uses only a few pointer variables, achieving O(1) space complexity."}]},Trees:{easy:[{id:1,question:"What is the root of a tree?",options:["Deepest node","Topmost node","Leftmost node","Any leaf node"],correct:1,explanation:"The root is the topmost node with no parent in a tree structure."},{id:2,question:"What is a leaf node?",options:["Root node","Node with children","Node with no children","Middle node"],correct:2,explanation:"A leaf node has no children in the tree structure."}],medium:[{id:3,question:"Time complexity of search in a balanced Binary Search Tree?",options:["O(n)","O(log n)","O(n\xb2)","O(1)"],correct:1,explanation:"Balanced BSTs maintain O(log n) height, providing logarithmic search time."},{id:4,question:"What is tree traversal?",options:["Sorting nodes","Visiting all nodes","Deleting nodes","Adding nodes"],correct:1,explanation:"Traversal means visiting each node in the tree exactly once."}],hard:[{id:5,question:"What is the height of a balanced binary tree with n nodes?",options:["O(1)","O(log n)","O(n)","O(n\xb2)"],correct:1,explanation:"A balanced binary tree has height O(log n) for n nodes."},{id:6,question:"What does AVL tree maintain?",options:["Complete balance","Height difference \u2264 1","Perfect balance","Node count balance"],correct:1,explanation:"AVL trees maintain balance by ensuring height difference between subtrees is at most 1."}]},Graphs:{easy:[{id:1,question:"What represents relationships between objects?",options:["Arrays","Trees","Graphs","Lists"],correct:2,explanation:"Graphs represent relationships between objects using nodes and edges."},{id:2,question:"What is a vertex in graph theory?",options:["Edge","Node","Path","Cycle"],correct:1,explanation:"Vertices (or nodes) are the fundamental units that graphs are built from."}],medium:[{id:3,question:"Which representation uses O(V\xb2) space?",options:["Adjacency List","Adjacency Matrix","Edge List","Incidence Matrix"],correct:1,explanation:"Adjacency Matrix uses a 2D array of size V\xd7V, requiring O(V\xb2) space."},{id:4,question:"What is BFS used for?",options:["Sorting","Shortest path","Level-order traversal","Both B and C"],correct:3,explanation:"BFS finds shortest paths in unweighted graphs and performs level-order traversal."}],hard:[{id:5,question:"Time complexity of Dijkstra algorithm?",options:["O(V)","O(E log V)","O(V\xb2)","O(E)"],correct:1,explanation:"Using binary heap, Dijkstra runs in O((V+E) log V) time."},{id:6,question:"What does topological sort do?",options:["Sorts nodes","Orders dependencies","Finds cycles","Calculates paths"],correct:1,explanation:"Topological sort orders nodes such that for every edge u\u2192v, u comes before v."}]},Sorting:{easy:[{id:1,question:"Which sort is stable?",options:["Quick Sort","Heap Sort","Merge Sort","Selection Sort"],correct:2,explanation:"Merge Sort maintains relative order of equal elements, making it stable."},{id:2,question:"Time complexity of Bubble Sort?",options:["O(n)","O(n log n)","O(n\xb2)","O(log n)"],correct:2,explanation:"Bubble Sort compares adjacent elements, giving O(n\xb2) in worst case."}],medium:[{id:3,question:"Which sort uses divide and conquer?",options:["Bubble Sort","Quick Sort","Insertion Sort","Selection Sort"],correct:1,explanation:"Quick Sort divides array around a pivot and recursively sorts subarrays."},{id:4,question:"Space complexity of Merge Sort?",options:["O(1)","O(n)","O(log n)","O(n\xb2)"],correct:1,explanation:"Merge Sort requires O(n) additional space for merging arrays."}],hard:[{id:5,question:"Best case time complexity of Quick Sort?",options:["O(n)","O(n log n)","O(n\xb2)","O(log n)"],correct:1,explanation:"When pivot divides array equally, Quick Sort achieves O(n log n) in best case."},{id:6,question:"Which sort is in-place?",options:["Merge Sort","Quick Sort","Both","Neither"],correct:1,explanation:"Quick Sort is in-place, while Merge Sort requires additional space."}]},"Dynamic Programming":{easy:[{id:1,question:"What does DP stand for?",options:["Data Processing","Dynamic Programming","Direct Path","Data Points"],correct:1,explanation:"DP stands for Dynamic Programming, a method for solving complex problems."},{id:2,question:"What is optimal substructure?",options:["Smallest solution","Solution from subsolutions","Fastest solution","Memory efficient"],correct:1,explanation:"Optimal substructure means optimal solution is built from optimal subsolutions."}],medium:[{id:3,question:"What is memoization?",options:["Memory allocation","Storing computed results","Variable naming","Code optimization"],correct:1,explanation:"Memoization stores results of expensive function calls to avoid recomputation."},{id:4,question:"Time complexity of Fibonacci with DP?",options:["O(2^n)","O(n)","O(n\xb2)","O(log n)"],correct:1,explanation:"DP reduces Fibonacci from exponential O(2^n) to linear O(n) time."}],hard:[{id:5,question:"What is the knapsack problem?",options:["Sorting items","Resource allocation","Path finding","String matching"],correct:1,explanation:"0/1 Knapsack is a resource allocation problem solved with DP."},{id:6,question:"Space optimization in DP?",options:["Use more memory","Use only current row","Store everything","Use recursion"],correct:1,explanation:"Many DP problems can be optimized to use O(min(n,m)) space instead of O(n*m)."}]},"Digital Electronics":{easy:[{id:1,question:"What is a logic gate?",options:["Physical gate","Electronic circuit performing logic","Software function","Network device"],correct:1,explanation:"Logic gates are electronic circuits that perform Boolean logic operations."},{id:2,question:"What does AND gate output?",options:["1 only if both inputs 1","1 if any input 1","Always 1","Always 0"],correct:0,explanation:"AND gate outputs 1 only when both inputs are 1."}],medium:[{id:3,question:"What is Boolean algebra?",options:["Number algebra","Logic algebra","String algebra","Matrix algebra"],correct:1,explanation:"Boolean algebra deals with binary variables and logic operations (AND, OR, NOT)."},{id:4,question:"What is a flip-flop?",options:["Logic gate","Memory element","Amplifier","Oscillator"],correct:1,explanation:"Flip-flops are bistable multivibrators used as memory elements in digital circuits."}],hard:[{id:5,question:"What is Karnaugh map used for?",options:["Circuit drawing","Logic simplification","Signal analysis","Power calculation"],correct:1,explanation:"K-maps provide a graphical method to simplify Boolean expressions."},{id:6,question:"What is race condition in digital circuits?",options:["Fast running","Unpredictable output","Power issue","Heat problem"],correct:1,explanation:"Race conditions occur when output depends on signal propagation delays."}]},"Signals & Systems":{easy:[{id:1,question:"What is a signal?",options:["Noise","Information function","Frequency","Amplitude"],correct:1,explanation:"A signal is a function that carries information, varying with time or space."},{id:2,question:"What is a system?",options:["Computer","Signal processor","Device","Network"],correct:1,explanation:"A system processes input signals to produce output signals."}],medium:[{id:3,question:"What does Fourier transform do?",options:["Time to frequency","Frequency to time","Amplitude scaling","Phase shifting"],correct:0,explanation:"Fourier transform converts signals from time domain to frequency domain."},{id:4,question:"What is convolution?",options:["Addition","Multiplication","Signal combination","Division"],correct:2,explanation:"Convolution combines two signals to show how one influences the other."}],hard:[{id:5,question:"What is Laplace transform used for?",options:["Time signals","Complex analysis","Differential equations","Both B and C"],correct:3,explanation:"Laplace transform converts differential equations to algebraic equations."},{id:6,question:"What is sampling theorem?",options:["Signal storage","Frequency limit","Nyquist rate","Both B and C"],correct:3,explanation:"Sampling theorem states sampling frequency must be at least twice signal bandwidth."}]},"Communication Systems":{easy:[{id:1,question:"What is modulation?",options:["Signal mixing","Carrier variation","Noise addition","Signal filtering"],correct:1,explanation:"Modulation varies a carrier signal property (amplitude, frequency, phase) with message."},{id:2,question:"What is AM?",options:["Audio Modulation","Amplitude Modulation","Angle Modulation","Analog Modulation"],correct:1,explanation:"AM varies carrier amplitude according to modulating signal."}],medium:[{id:3,question:"What is bandwidth?",options:["Signal strength","Frequency range","Power consumption","Distance covered"],correct:1,explanation:"Bandwidth is the range of frequencies occupied by a signal."},{id:4,question:"What is multiplexing?",options:["Signal division","Multiple signals on one channel","Signal amplification","Noise reduction"],correct:1,explanation:"Multiplexing combines multiple signals for transmission over single channel."}],hard:[{id:5,question:"What is Shannon capacity?",options:["Channel speed","Maximum data rate","Signal power","Noise level"],correct:1,explanation:"Shannon capacity formula gives maximum error-free data transmission rate."},{id:6,question:"What is OFDM?",options:["Single carrier","Multiple carriers","Analog modulation","Digital coding"],correct:1,explanation:"OFDM divides signal into multiple subcarriers for efficient transmission."}]},"Control Systems":{easy:[{id:1,question:"What is feedback in control systems?",options:["Forward path","Output to input","Input amplification","Error correction"],correct:1,explanation:"Feedback feeds output signal back to input for comparison and correction."},{id:2,question:"What is stability?",options:["System speed","Bounded output","High gain","Low noise"],correct:1,explanation:"Stability means system output remains bounded for bounded inputs."}],medium:[{id:3,question:"What is transfer function?",options:["Input function","Output/Input ratio","Error function","Control function"],correct:1,explanation:"Transfer function is Laplace transform of output over input for LTI systems."},{id:4,question:"What does PID stand for?",options:["Proportional Integral Derivative","Primary Input Device","Process Identification Data","Parameter Input Delay"],correct:0,explanation:"PID controller uses Proportional, Integral, and Derivative terms for control."}],hard:[{id:5,question:"What is root locus?",options:["System roots","Pole-zero plot","Stability analysis","Both B and C"],correct:3,explanation:"Root locus plots closed-loop poles as gain varies for stability analysis."},{id:6,question:"What is state space representation?",options:["Single equation","Differential equations","Transfer function","Block diagram"],correct:1,explanation:"State space uses first-order differential equations to represent system dynamics."}]},Microprocessors:{easy:[{id:1,question:"What is a microprocessor?",options:["Memory chip","CPU on chip","Storage device","Input device"],correct:1,explanation:"Microprocessor is a CPU implemented on a single integrated circuit chip."},{id:2,question:"What is ALU?",options:["Address unit","Arithmetic Logic Unit","Array Logic Unit","Analog Logic Unit"],correct:1,explanation:"ALU performs arithmetic and logical operations in the CPU."}],medium:[{id:3,question:"What is pipelining?",options:["Parallel processing","Sequential execution","Memory access","I/O operation"],correct:0,explanation:"Pipelining allows simultaneous execution of multiple instructions in different stages."},{id:4,question:"What is interrupt?",options:["CPU stop","External signal","Program end","Error condition"],correct:1,explanation:"Interrupt is a signal that causes CPU to suspend current task and service request."}],hard:[{id:5,question:"What is cache memory?",options:["Main memory","Fast buffer memory","Secondary storage","Register file"],correct:1,explanation:"Cache is high-speed memory that stores frequently accessed data and instructions."},{id:6,question:"What is RISC architecture?",options:["Complex instructions","Reduced instruction set","Register intensive","Memory oriented"],correct:1,explanation:"RISC uses simple instructions that execute quickly, with more registers."}]}};return((null===(i=a[e])||void 0===i?void 0:i[t])||(null===(n=a[e])||void 0===n?void 0:n.easy)||[]).sort(()=>Math.random()-.5).slice(0,o)},u={getQuestions:async function(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5;if(!e||!t)throw new Error("Topic and difficulty are required");try{return await n.get("/api/quiz/questions",{params:{topic:e,difficulty:t,count:i}})}catch(o){return console.warn("Quiz API failed, using mock questions:",o),await new Promise(e=>setTimeout(e,500)),{data:{questions:d(e,t,i),topic:e,difficulty:t,count:Math.min(i,d(e,t,i).length)}}}},submitQuiz:async e=>{if(!e)throw new Error("Quiz data is required");try{return await n.post("/api/quiz/submit",e)}catch(o){var t,i;console.warn("Quiz submission API failed, using mock results:",o),await new Promise(e=>setTimeout(e,1e3));const n=Math.floor(40*Math.random())+60;return{data:{score:n,totalQuestions:(null===(t=e.answers)||void 0===t?void 0:t.length)||5,correctAnswers:Math.floor(n/100*((null===(i=e.answers)||void 0===i?void 0:i.length)||5)),timeSpent:e.timeSpent||300,feedback:n>=80?"Excellent performance!":n>=60?"Good job! Keep practicing.":"Needs more practice.",topicMastery:Math.min(100,n+Math.floor(20*Math.random()))}}}},getQuizHistory:async e=>{try{return await n.get("/api/quiz/history",{params:{userId:e}})}catch(t){return console.warn("Quiz history API failed, using mock data:",t),{data:{quizzes:[{id:1,topic:"Arrays",score:85,date:"2024-01-10",difficulty:"medium"},{id:2,topic:"Linked Lists",score:78,date:"2024-01-09",difficulty:"easy"},{id:3,topic:"Trees",score:92,date:"2024-01-08",difficulty:"hard"}]}}}}}}}]);